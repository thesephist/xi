#!/usr/bin/env oak

// Xi is a minimal concatenative stack programming language that uses Oak types
// and semantics.

{
	println: println
	slice: slice
	map: map
	each: each
	filter: filter
	every: every
	partition: partition
	entries: entries
	loop: loop
} := import('std')
{
	digit?: digit?
	join: join
	split: split
	trim: trim
} := import('str')
{
	sort!: sort!
} := import('sort')
{
	printf: printf
} := import('fmt')

fn Stack {
	// buffer backing the stack
	mem := []
	// index points to the next insertion slot
	index := 0

	fn pop if index {
		0 -> ?
		_ -> {
			index <- index - 1
			mem.(index)
		}
	}
	fn push(it) {
		mem.(index) := it
		index <- index + 1
	}
	fn peek if index {
		0 -> ?
		_ -> mem.(index - 1)
	}

	{
		pop: pop
		push: push
		peek: peek
		clear: fn() index <- 0
		items: fn() mem |> slice(0, index)
	}
}

fn parse(program) {
	index := 0
	tokens := program |> split(' ') |> with filter() fn(s) s |> trim() != ''

	fn parseTokens(stmts) if index >= len(tokens) {
		true -> stmts
		_ -> if token := tokens.(index) {
			'(' -> {
				index <- index + 1
				parseTokens(stmts << parseTokens([]))
			}
			'[' -> {
				index <- index + 1
				parseTokens(stmts << {
					type: :list
					val: parseTokens([])
				})
			}
			'{' -> {
				index <- index + 1
				parseTokens(stmts << {
					type: :object
					val: {
						obj := {}
						parseTokens([]) |> partition(2) |> with each() fn(pair) {
							[key, val] := pair
							obj.(key) := val
						}
						obj
					}
				})
			}
			']', '}', ')' -> {
				index <- index + 1
				stmts
			}
			_ -> {
				index <- index + 1
				parseTokens(stmts << token)
			}
		}
	}
	parseTokens([])
}

// toString converts Xi values to string representations suitable for printing
// in a REPL environment.
fn toString(word) if type(word) {
	:list -> '( ' + word |> join(' ') + ' )'
	:object -> if word {
		{ type: :list, val: _ } -> '[ ' + word.val |> map(toString) |> join(' ') + ' ]'
		{ type: :object, val: _ } -> '{ ' + word.val |>
			entries() |>
			map(fn(entry) {
				[key, val] := entry
				toString(key) + ' ' + toString(val)
			}) |>
			join(' ') + ' }'
	}
	:int, :float -> string(word)
	:string -> '\'' + word + '\''
	_ -> string(word)
}

fn number?(s) s |> split() |> with every() fn(c) c = '.' | digit?(c)
fn str?(s) s.0 = '\'' & s.(len(s) - 1) = '\''

// literal? reports whether a parsed word represents a Xi value literal
fn literal?(word) if {
	word = ? -> false

	type(word) = :list
	word = { type: _, val: _ }
	number?(word)
	str?(word)
	word = 'true'
	word = 'false' -> true

	_ -> false
}

fn literal(word) if {
	type(word) = :list -> word
	word = { type: :list, val: _ } -> {
		type: :list
		val: word.val |> map(literal)
	}
	// TODO: evaluate each key, value
	word = { type: :object, val: _ } -> word
	number?(word) -> float(word)
	str?(word) -> word |> slice(1, len(word) - 1)
	word = 'true' -> true
	word = 'false' -> false
}

fn eval(words, stack, scope) if words.1 {
	// define a new word
	':' -> scope.(words.0) := words |> slice(2)
	// evaluate a statement
	_ -> words |> with each() fn(word) if word {
		// introspection
		'.' -> println(stack.pop() |> toString())
		'?' -> println('[ ' + stack.items() |> map(toString) |> join(' ') + ' ]')
		'??' -> println('{\n' + scope |> entries() |> sort!(fn(pair) pair.0) |> map(fn(pair) {
			[key, val] := pair
			'  ' + toString(key) + ' : ' + toString(pair)
		}) |> join('\n') + '\n}')

		// stack manipulation
		'dup' -> stack.push(stack.peek())
		'dip' -> {
			defn := stack.pop()
			dipped := stack.pop()
			defn |> eval(stack, scope)
			stack.push(dipped)
		}
		'drop' -> stack.pop()
		'swap' -> {
			a := stack.pop()
			b := stack.pop()
			stack.push(a)
			stack.push(b)
		}
		'clear' -> stack.clear()

		// operators
		'+' -> stack.push(stack.pop() + stack.pop())
		'-' -> stack.push({
			tmp := stack.pop()
			stack.pop() - tmp
		})
		'*' -> stack.push(stack.pop() * stack.pop())
		'/' -> stack.push({
			tmp := stack.pop()
			stack.pop() / tmp
		})
		'%' -> stack.push({
			tmp := stack.pop()
			stack.pop() % tmp
		})
		'&' -> stack.push(stack.pop() & stack.pop())
		'|' -> stack.push(stack.pop() | stack.pop())
		'^' -> stack.push(stack.pop() ^ stack.pop())
		'=' -> stack.push(stack.pop() = stack.pop())
		'<' -> stack.push(stack.pop() > stack.pop())
		'>' -> stack.push(stack.pop() < stack.pop())
		'<=' -> stack.push(stack.pop() >= stack.pop())
		'>=' -> stack.push(stack.pop() <= stack.pop())
		'!' -> stack.push(!stack.pop())

		// primitives
		'?:' -> {
			ifFalse := stack.pop()
			ifTrue := stack.pop()
			stack.push(if cond := stack.pop() {
				true -> ifTrue
				_ -> ifFalse
			})
		}
		'call' -> stack.pop() |> eval(stack, scope)
		// array and object functions
		'nth' -> {
			key := stack.pop()
			if target := stack.pop() {
				{ type: :list, val: _ } -> stack.push(target.val.(int(key)))
				{ type: :object, val: _ } -> stack.push(target.val.(key))
				_ -> {
					printf('Error: cannot access key {{0}} of {{1}}', key, target)
				}
			}
		}
		'nth!' -> {
			val := stack.pop()
			key := stack.pop()
			if target := stack.peek() {
				{ type: :list, val: _ } -> target.val.(int(key)) := val
				{ type: :object, val: _ } -> target.val.(key) := val
				_ -> {
					printf('Error: cannot access key {{0}} of {{1}}', key, target)
				}
			}
		}
		'len' -> if target := stack.pop() {
			{ type: _, val: _ } -> stack.push(float(len(target.val)))
			_ -> {
				printf('Error: cannot get len of {{0}}', target)
				stack.push(0)
			}
		}

		// literals and definitions
		_ -> if literal?(word) {
			true -> literal(word) |> stack.push()
			_ -> if defn := scope.(word) {
				? -> printf('Error: unknown word "{{0}}"', word)
				_ -> defn |> eval(stack, scope)
			}
		}
	}
}

// main

scope := {}
stack := Stack()

// language prelude
[
	// operators
	'++ : 1 +'
	'-- : 1 -'
	'neg : 0 swap -'
	'abs : dup 0 >= ( ) ( neg ) if'
	'zero? : 0 ='
	'even? : 2 % 0 ='
	'odd? : 2 % 1 ='
	'pos? : 0 >'
	'neg? : 0 <'
	'max : dup2 > ( drop ) ( nip ) if'
	'min : dup2 < ( drop ) ( nip ) if'
	// n factor -> bool
	'divisible? : % zero?'

	// stack shuffling
	'nip : swap drop'
	'nipd : ( nip ) dip'
	'dip2 : swap ( dip ) dip'
	'dip3 : swap ( dip2 ) dip'
	'dip4 : swap ( dip3 ) dip'
	'drop2 : drop drop'
	'drop3 : drop2 drop'
	// x y -> x x y
	'dupd : ( dup ) dip'
	// x y -> x y x y
	'dup2 : over over'
	// x y z -> x y z x y z
	'dup3 : pick pick pick'
	// x y z -> y x z
	'swapd : ( swap ) dip'
	// x y -> x y x
	'over : dupd swap'
	// x y z -> y z x
	'rot : swapd swap'
	// x y z -> z x y
	'-rot : swap swapd'
	// w x y z -> x y w z
	'rotd : ( rot ) dip'
	// w x y z -> y w x z
	'-rotd : ( -rot ) dip'
	// x y -> y x y
	'tuck : dup -rot'
	// x y z -> z y x
	'spin : -rot swap'
	// x y z -> x y z x
	'pick : rot dup ( -rot ) dip'
	// w x y z -> w x y w z
	'pickd : ( pick ) dip'
	// w x y z -> x y z w
	'rot4 : ( swap ) dip2 rot'
	// w x y z -> z w x y
	'-rot4 : -rot ( swap ) dip2'
	// w x y z -> w x y z w
	'reach : pickd swap'
	// x y quot -> quot(x,y) y
	'keep : over ( call ) dip'

	// primitive ops
	'<< : ( dup len ) dip nth!'

	// combinators
	'if : ?: call'
	'if* : ( dup ) dip2 if'
	'when : ( ) if'
	'when* : ( ) if*'
	'unless : ( ) swap if'
	'unless* : ( ) swap if*'
	'twice : dup ( call ) dip call'
	'thrice : dup dup ( call ) dip2 ( call ) dip call'
	'bi : ( keep ) dip call'
	'tri : ( ( keep ) dip keep ) dip call'
	'quad : ( ( ( keep ) dip keep ) dip keep ) dip call'

	// sequencers
	// [x..] -> bool
	'empty? : len zero?'
	// n quot: ( i -> _ ) -> _
	'--each-integer-sub : pick pick > ( rot ( dup2 ( call ) dip2 ) dip -rot ( ++ ) dip --each-integer-sub ) ( drop3 ) if'
	'each-integer : 0 swap --each-integer-sub'
	// [x..] quot: ( x -> _ ) -> _
	'each : ( dup len ) dip swap ( swap ( dupd nth ) dip tuck call ) each-integer drop2'
	// [x..] quot: ( acc x -> acc ) acc -> acc
	'reduce : -rot ( dup len ) dip swap ( swap ( dupd nth ) dip ( swap ) dip2 dup ( call ) dip swapd ) each-integer drop2'
	// [x..] quot: ( x -> y ) -> [y..]
	'map : [ ] -rot ( dup len ) dip swap ( swap ( dupd nth ) dip ( swap ) dip2 dup ( call << swap ) dip ) each-integer drop2'
	// [x..] quot: ( x -> bool ) -> [x..]
	'filter : [ ] -rot ( dup len ) dip swap ( swap ( dupd nth ) dip ( swap ) dip2 dup ( dupd call ( << ) ( drop ) if swap ) dip ) each-integer drop2'
	// [x..] a b [y..] -> [y.. x..]
	'--sub-slice : pick pick < ( reach reach nth << ( ++ ) dip2 --sub-slice ) ( -rot4 drop3 ) if'
	// [x..] a b -> [x..]
	'slice : [ ] --sub-slice'

	// stdlib
	// c [x..] a b -> c [x.. a] a+=c b
	'--push-into-list-and-incr : dupd ( << ) dip2 ( pick + ) dip'
	// c [x..] a b -> [x..b:c]
	'--iterate-if-less : dup2 < ( --push-into-list-and-incr --iterate-if-less ) ( drop2 nip ) if'
	// a b c -> [a..b:c]
	'a..b:c : -rot [ ] -rot --iterate-if-less'
	// a b -> [a..b:1]
	'a..b : 1 a..b:c'
	'0..b : 0 swap a..b'
	'1..b : 1 swap a..b'

	// fizzbuzz (example)
	// n -> _
	'fizz-n : dup 15 divisible? ( \'FizzBuzz\' . drop ) ( dup 3 divisible? ( \'Fizz\' . drop ) ( dup 5 divisible? ( \'Buzz\' . drop ) ( . ) if ) if ) if'
	// max -> _
	'fizzbuzz : ++ 1..b ( fizz-n ) each'
	// n -> factorial(n)
	'factorial : ++ 1..b ( * ) 1 reduce'
] |> with each() fn(stmt) stmt |> parse() |> eval(stack, scope)

with loop() fn(_, break) {
	print('xi) ')
	evt := input()
	if evt.type {
		:error -> break()
		_ -> if program := evt.data {
			'exit' -> break()
			_ -> program |> parse() |> eval(stack, scope)
		}
	}
}

